use std::convert::TryFrom;

use serde::Deserialize;
use tokio::time::Duration;

use crate::cve::Cve;
use crate::error::{Error, RequestResult};

#[derive(Debug, Clone)]
pub struct Nvd {
    http_client: reqwest::Client,
}

impl Nvd {
    pub fn new() -> Self {
        Nvd {
            http_client: reqwest::Client::new(),
        }
    }

    pub async fn cve_by_id(&self, id: &str) -> RequestResult<NvdResult> {
        let url = format!("https://services.nvd.nist.gov/rest/json/cve/1.0/{}", id);
        let resp = self
            .http_client
            .get(&url)
            .timeout(Duration::from_secs(5))
            .send()
            .await
            .map_err(|e| Error::HttpClientError {
                why: "call to NVD failed",
                source: e,
            })?;

        if !resp.status().is_success() {
            return Err(Error::RequestFailed {
                id: id.to_string(),
                status_code: resp.status(),
            });
        }

        let nvd = resp.json::<NvdResult>().await.map_err(|e| Error::ParserError {
            what: "HTTP body".to_string(),
            to: "NVD",
            why: e.to_string(),
        })?;

        if nvd.total_results != 1 {
            return Err(Error::ParserError {
                what: "NVD response".to_string(),
                to: "NvdResult",
                why: format!("size of returned results is assumed to be exactly 1, was {}", nvd.total_results),
            });
        }

        Ok(nvd)
    }
}

impl Default for Nvd {
    fn default() -> Self {
        Nvd::new()
    }
}

#[derive(Debug, Deserialize)]
pub struct NvdResult {
    result: NvdItemArray,
    #[serde(rename = "totalResults")]
    total_results: usize,
}

#[derive(Debug, Deserialize)]
pub struct NvdItemArray {
    #[serde(rename = "CVE_Items")]
    items: Vec<NvdItem>
}

#[derive(Debug, Deserialize)]
pub struct NvdItem {
    pub cve: NvdCve,
    pub impact: NvdImpact,
}

#[derive(Debug, Deserialize)]
pub struct NvdCve {
    #[serde(rename = "CVE_data_meta")]
    pub meta_data: NvdCveMetadata,
}

#[derive(Debug, Deserialize)]
pub struct NvdCveMetadata {
    #[serde(rename = "ID")]
    pub id: String,
}

#[derive(Debug, Deserialize)]
pub struct NvdImpact {
    #[serde(rename = "baseMetricV3")]
    pub base_metric: NvdBaseMetricV3,
}

#[derive(Debug, Deserialize)]
pub struct NvdBaseMetricV3 {
    #[serde(rename = "cvssV3")]
    cvss3: Cvss3,
}

#[derive(Debug, Deserialize)]
pub struct Cvss3 {
    #[serde(rename = "baseScore")]
    pub base_score: f64,
    #[serde(rename = "vectorString")]
    pub scoring_vector: String,
}

impl TryFrom<NvdResult> for Cve {
    type Error = Error;

    fn try_from(nvd: NvdResult) -> Result<Self, Self::Error> {
        if nvd.result.items.len() != 1 {
            return Err(Error::ParserError {
                what: "NvdResult".to_string(),
                to: "CVE",
                why: format!("size of results is assumed to be exactly 1, was {}", nvd.result.items.len()),
            });
        }
        let result = nvd.result.items.into_iter().next().unwrap(); // Safe, because of check above
        let name = result.cve.meta_data.id;
        let scoring_vector = result.impact.base_metric.cvss3.scoring_vector;

        Cve::from_cve_str(name, scoring_vector)
    }
}

#[cfg(test)]
mod tests {
    use std::convert::TryInto;
    use std::path::PathBuf;

    use spectral::prelude::*;

    use crate::Cve;
    use crate::nvd::NvdResult;

    #[test]
    fn parse_response() {
        let mut json_file = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        json_file.push("tests/data/nvd-CVE-2020-25705.json");
        let json = std::fs::read_to_string(json_file).expect("Failed to read json file");

        let nvdcve: Result<NvdResult, _> = serde_json::from_str(&json);

        asserting("json has been read successfully").that(&nvdcve).is_ok();
    }

    #[test]
    fn parse_response_to_cve() {
        let mut json_file = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        json_file.push("tests/data/nvd-CVE-2020-25705.json");
        let json = std::fs::read_to_string(json_file).expect("Failed to read json file");
        let expected = Cve::from_cve_str("CVE-2020-25705".to_string(), "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N".to_string()).unwrap();

        let nvdcve: Result<NvdResult, _> = serde_json::from_str(&json);
        asserting("json has been read successfully").that(&nvdcve).is_ok();

        let cve: Result<Cve, _> = nvdcve.unwrap().try_into();

        asserting("NvdResult has been successfully transformed into a CVE")
            .that(&cve)
            .is_ok()
            .is_equal_to(&expected);
    }
}
