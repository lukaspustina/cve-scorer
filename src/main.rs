pub mod error {
    use thiserror::Error;

    #[derive(Error, Debug)]
    pub enum Error {
        #[error("internal error: {msg}")]
        InternalError { msg: &'static str },
        #[error("failed to parse '{what}' to {to} because {why}")]
        ParserError {
            what: String,
            to: &'static str,
            why: String,
        },
        #[error("HTTP client error: {why}")]
        HttpClientError { why: &'static str, source: reqwest::Error },
        #[error("Request for '{id}' failed because with status code {status_code}")]
        RequestFailed {
            id: String,
            status_code: reqwest::StatusCode,
        },
    }

    pub type RequestResult<T> = std::result::Result<T, Error>;
    pub type Result<T> = std::result::Result<T, Error>;
}

pub mod redhat {
    use crate::cve::Cve;
    use crate::error::{Error, RequestResult};
    use cvss::v3::Base;
    use serde::Deserialize;
    use std::convert::TryFrom;
    use std::str::FromStr;
    use tokio::time::Duration;

    #[derive(Debug, Clone)]
    pub struct RedHat {
        http_client: reqwest::Client,
    }

    impl RedHat {
        pub fn new() -> Self {
            RedHat {
                http_client: reqwest::Client::new(),
            }
        }

        pub async fn cve_by_id(&self, id: String) -> RequestResult<RedHatCve> {
            let url = format!("https://access.redhat.com/labs/securitydataapi/cve/{}.json", &id);
            let resp = self
                .http_client
                .get(&url)
                .timeout(Duration::from_secs(5))
                .send()
                .await
                .map_err(|e| Error::HttpClientError {
                    why: "call to RedHat failed",
                    source: e,
                })?;

            if !resp.status().is_success() {
                return Err(Error::RequestFailed {
                    id,
                    status_code: resp.status(),
                });
            }

            let redhat = resp.json::<RedHatCve>().await.map_err(|e| Error::ParserError {
                what: "HTTP body".to_string(),
                to: "RedHat",
                why: e.to_string(),
            })?;

            Ok(redhat)
        }
    }

    impl Default for RedHat {
        fn default() -> Self {
            RedHat::new()
        }
    }

    #[derive(Debug, Deserialize)]
    pub struct RedHatCve {
        pub name: String,
        pub cvss3: Cvss3,
    }

    #[derive(Debug, Deserialize)]
    #[serde(rename = "cvss3")]
    pub struct Cvss3 {
        #[serde(rename = "cvss3_base_score")]
        pub base_score: String,
        #[serde(rename = "cvss3_scoring_vector")]
        pub scoring_vector: String,
    }

    impl TryFrom<RedHatCve> for Cve {
        type Error = Error;

        fn try_from(redhat: RedHatCve) -> Result<Self, Self::Error> {
            let name = redhat.name;
            let scoring_vector = redhat.cvss3.scoring_vector;
            let base = Base::from_str(&scoring_vector).map_err(|e| Error::ParserError {
                what: scoring_vector,
                to: "Cve",
                why: e.to_string(),
            })?;

            let base_score = base.score().value();
            let severity = base.severity();
            Ok(Cve {
                id: name,
                base,
                base_score,
                severity,
            })
        }
    }
}

pub mod cve {
    use cvss::v3::Base;
    use cvss::Severity;

    #[derive(Debug)]
    pub struct Cve {
        pub id: String,
        pub base: Base,
        pub base_score: f64,
        pub severity: Severity,
    }
}

use crate::cve::Cve;
use crate::error::{Error, Result};
use crate::redhat::RedHat;
use futures::stream::{self, StreamExt};
use std::convert::TryInto;
use std::io::Write;
use structopt::StructOpt;
use tabwriter::TabWriter;

#[derive(Debug, StructOpt)]
#[structopt(name = "cve-scorer", author = env!("CARGO_PKG_AUTHORS"), about = env!("CARGO_PKG_DESCRIPTION"))]
struct Opts {
    /// CVE ids to retrieve
    #[structopt(required = true)]
    ids: Vec<String>,
}

#[tokio::main]
async fn main() -> std::result::Result<(), Box<dyn std::error::Error>> {
    let opts = Opts::from_args();
    let redhat = RedHat::new();

    let requests: Vec<_> = opts.ids.into_iter().map(|id| single_request(&redhat, id)).collect();

    let cves = stream::iter(requests).buffer_unordered(5).collect::<Vec<_>>().await;

    output(&cves).expect("Failed to output results");

    Ok(())
}

async fn single_request(redhat: &RedHat, id: String) -> Result<Cve> {
    let cve: Cve = redhat.cve_by_id(id).await?.try_into()?;

    Ok(cve)
}

fn output(cves: &[Result<Cve>]) -> Result<()> {
    let mut tw = TabWriter::new(vec![]);
    for res in cves {
        match res {
            Ok(cve) => {
                let _ = writeln!(
                    tw,
                    "{cve}\t{score}\t{severity}\t{vector}",
                    cve = &cve.id,
                    score = cve.base_score,
                    severity = cve.severity.as_str(),
                    vector = &cve.base.to_string()
                );
            }
            Err(e) => match e {
                Error::RequestFailed { id, status_code } => {
                    let _ = writeln!(tw, "{} failed because {}", id, status_code);
                }
                e => {
                    let _ = writeln!(tw, "{}", e.to_string());
                }
            },
        }
    }
    tw.flush().map_err(|_| Error::InternalError {
        msg: "failed to flush output",
    })?;
    let buffer = tw.into_inner().map_err(|_| Error::InternalError {
        msg: "failed to get tab writer buffer",
    })?;
    let written = String::from_utf8(buffer).map_err(|_| Error::InternalError {
        msg: "failed to create string from buffer",
    })?;
    println!("{}", written);

    Ok(())
}
