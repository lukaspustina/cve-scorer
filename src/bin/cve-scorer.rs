use cvescorer::{Cve, SourceType, Nvd};
use cvescorer::RedHat;
use cvescorer::{Error, Result};
use futures::stream::{self, StreamExt};
use std::convert::TryInto;
use std::io::Write;
use structopt::StructOpt;
use tabwriter::TabWriter;

#[derive(Debug, StructOpt)]
#[structopt(
    name = "cve-scorer",
    author = env!("CARGO_PKG_AUTHORS"),
    about = env!("CARGO_PKG_DESCRIPTION"),
    global_setting(structopt::clap::AppSettings::UnifiedHelpMessage),
)]
/// cve-scorer helps you to assess CVEs by retrieving their CVSS scores.
///
/// Have you ever received an Ubuntu Security Notice for one project which
/// contains 45 CVEs and you now have to decide if these affect you?
/// cve-scorer is here to help you!
///
/// Example: cve-scorer CVE-2020-14802 CVE-2020-14803 CVE-2020-14804
struct Opts {
    /// CVE ids to retrieve
    ids: Vec<String>,
    /// Set to sort the results by severity
    #[structopt(short = "s", long = "sort")]
    sort: bool,
    /// Show link to NVD details webpage
    #[structopt(short = "l", long = "link")]
    link: bool,
    //#[structopt(long = "source", parse(from_os_str = cvescorer::SourceType::from_str)), ]
    #[structopt(long = "source", possible_values(&["nvd", "redhat"]), default_value = "nvd")]
    source: SourceType,
}

#[tokio::main]
async fn main() -> std::result::Result<(), Box<dyn std::error::Error>> {
    let opts = Opts::from_args();
    if opts.ids.is_empty() {
        let _ = Opts::clap().print_long_help();
        return Ok(());
    }
    let ids = opts.ids.iter().map(|id| id.trim_end_matches(|x| char::is_ascii_punctuation(&x)));

    let cves = get_cvss(&opts.source, ids).await;

    output(opts.sort, opts.link, &cves).expect("Failed to output results");

    Ok(())
}

async fn get_cvss<'a, I: Iterator<Item = &'a str>>(source: &SourceType, ids: I) -> Vec<Result<Cve>> {
    match source {
        SourceType::NVD => {
            let nvd = Nvd::new();
            let requests: Vec<_> = ids.map(|id| single_reques_nvd(&nvd, id)).collect();
            stream::iter(requests).buffer_unordered(10).collect::<Vec<_>>().await
        },
        SourceType::RedHat => {
            let redhat = RedHat::new();
            let requests: Vec<_> = ids.map(|id| single_reques_redhat(&redhat, id)).collect();
            stream::iter(requests).buffer_unordered(10).collect::<Vec<_>>().await
        },
    }
}

async fn single_reques_nvd(nvd: &Nvd, id: &str) -> Result<Cve> {
    nvd.cve_by_id(id).await?.try_into()
}

async fn single_reques_redhat(redhat: &RedHat, id: &str) -> Result<Cve> {
    redhat.cve_by_id(id).await?.try_into()
}

fn output(sort: bool, link: bool, cves: &[Result<Cve>]) -> Result<()> {
    let mut oks: Vec<&Cve> = cves.iter().filter(|x| x.is_ok()).map(|x| x.as_ref().unwrap()).collect();
    if sort {
        oks.sort_by(|this, that| Cve::partial_cmp(this, that).unwrap()); // safe
        oks.reverse(); // We want to reverse to show the highest CVSS first
    }

    let errs: Vec<&Error> = cves
        .iter()
        .filter(|x| x.is_err())
        .map(|x| x.as_ref().unwrap_err())
        .collect();

    let mut tw = TabWriter::new(vec![]);
    for cve in oks {
        let _ = write!(
            tw,
            "{cve}\t{score}\t{severity}\t{vector}",
            cve = &cve.id,
            score = cve.base_score,
            severity = cve.severity.as_str(),
            vector = &cve.base.to_string()
        );
        if link {
            let _ = write!(tw, "\thttps://nvd.nist.gov/vuln/detail/{}", cve.id);
        }
        let _ = writeln!(tw);
    }
    for e in errs {
        match e {
            Error::RequestFailed { id, status_code } => {
                let _ = writeln!(tw, "{} failed because {}", id, status_code);
            }
            e => {
                let _ = writeln!(tw, "{}", e.to_string());
            }
        }
    }
    tw.flush().map_err(|_| Error::InternalError {
        msg: "failed to flush output",
    })?;
    let buffer = tw.into_inner().map_err(|_| Error::InternalError {
        msg: "failed to get tab writer buffer",
    })?;
    let written = String::from_utf8(buffer).map_err(|_| Error::InternalError {
        msg: "failed to create string from buffer",
    })?;
    println!("{}", written);

    Ok(())
}
